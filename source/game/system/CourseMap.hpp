#pragma once

#include <rk_types.h>

#include <decomp.h>

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

// PAL: 0x80512694..0x8051271c
UNKNOWN_FUNCTION(createInstance__Q26System9CourseMapFv);
// PAL: 0x8051271c..0x8051276c
UNKNOWN_FUNCTION(destroyInstance__Q26System9CourseMapFv);
// PAL: 0x8051276c..0x805127ac
UNKNOWN_FUNCTION(__ct__Q25Field9CourseMapFv);
// PAL: 0x805127ac..0x805127ec
UNKNOWN_FUNCTION(__dt__Q25Field9CourseMapFv);
// PAL: 0x805127ec..0x80512c10
UNKNOWN_FUNCTION(CourseMap_init);
// PAL: 0x80512c10..0x80512c2c
UNKNOWN_FUNCTION(loadFile__Q26System9CourseMapFlPCc);
// PAL: 0x80512c2c..0x80512c6c
UNKNOWN_FUNCTION(CourseMapHeader_ct);
// PAL: 0x80512c6c..0x80512c78
UNKNOWN_FUNCTION(unk_80512c6c);
// PAL: 0x80512c78..0x80512c94
UNKNOWN_FUNCTION(unk_80512c78);
// PAL: 0x80512c94..0x80512c9c
UNKNOWN_FUNCTION(unk_80512c94);
// PAL: 0x80512c9c..0x80512cac
UNKNOWN_FUNCTION(unk_80512c9c);
// PAL: 0x80512cac..0x80512cb4
UNKNOWN_FUNCTION(setIndex__Q26System15MapdataAreaBaseFUs);
// PAL: 0x80512cb4..0x80512cd0
UNKNOWN_FUNCTION(getAreaCount__Q26System9CourseMapCFv);
// PAL: 0x80512cd0..0x80512cec
UNKNOWN_FUNCTION(unk_80512cd0);
// PAL: 0x80512cec..0x80512d08
UNKNOWN_FUNCTION(unk_80512cec);
// PAL: 0x80512d08..0x80512d24
UNKNOWN_FUNCTION(unk_80512d08);
// PAL: 0x80512d24..0x80512d40
UNKNOWN_FUNCTION(unk_80512d24);
// PAL: 0x80512d40..0x80512d4c
UNKNOWN_FUNCTION(Stageinfo_isNarrowMode);
// PAL: 0x80512d4c..0x80512d58
UNKNOWN_FUNCTION(unk_80512d4c);
// PAL: 0x80512d58..0x80512d64
UNKNOWN_FUNCTION(unk_80512d58);
// PAL: 0x80512d64..0x80512e84
UNKNOWN_FUNCTION(parseStage__Q26System9CourseMapFUl);
// PAL: 0x80512e84..0x80512fa4
UNKNOWN_FUNCTION(parseMissionPoints__Q26System9CourseMapFUl);
// PAL: 0x80512fa4..0x805130c4
UNKNOWN_FUNCTION(parseCannonPoints__Q26System9CourseMapFUl);
// PAL: 0x805130c4..0x805131e4
UNKNOWN_FUNCTION(parseJugemPoints__Q26System9CourseMapFUl);
// PAL: 0x805131e4..0x80513304
UNKNOWN_FUNCTION(parseCameras__Q26System9CourseMapFUl);
// PAL: 0x80513304..0x80513398
UNKNOWN_FUNCTION(parseAreas__Q26System9CourseMapFUl);
// PAL: 0x80513398..0x805134c8
UNKNOWN_FUNCTION(parsePointInfo__Q26System9CourseMapFUl);
// PAL: 0x805134c8..0x80513600
UNKNOWN_FUNCTION(parseGeoObjs__Q26System9CourseMapFUl);
// PAL: 0x80513600..0x80513640
UNKNOWN_FUNCTION(unk_80513600);
// PAL: 0x80513640..0x8051377c
UNKNOWN_FUNCTION(KmpHolder_parseCheckpoints);
// PAL: 0x8051377c..0x80513adc
UNKNOWN_FUNCTION(KmpHolder_parseCheckpaths);
// PAL: 0x80513adc..0x80513bfc
UNKNOWN_FUNCTION(parseItemPoints__Q26System9CourseMapFUl);
// PAL: 0x80513bfc..0x80513d18
UNKNOWN_FUNCTION(parseItemPaths__Q26System9CourseMapFUl);
// PAL: 0x80513d18..0x80513e40
UNKNOWN_FUNCTION(parseEnemyPoints__Q26System9CourseMapFUl);
// PAL: 0x80513e40..0x80513f5c
UNKNOWN_FUNCTION(parseEnemyPaths__Q26System9CourseMapFUl);
// PAL: 0x80513f5c..0x805140dc
UNKNOWN_FUNCTION(parseKartpoints__Q26System9CourseMapFUl);
// PAL: 0x805140dc..0x80514100
UNKNOWN_FUNCTION(get__Q26System19MapdataAreaAccessorCFUs);
// PAL: 0x80514100..0x80514124
UNKNOWN_FUNCTION(unk_80514100);
// PAL: 0x80514124..0x80514148
UNKNOWN_FUNCTION(KartpointHolder_getKartpoint);
// PAL: 0x80514148..0x80514194
UNKNOWN_FUNCTION(KmpHolder_getGlobalObj);
// PAL: 0x80514194..0x80514208
UNKNOWN_FUNCTION(getPointInfo__Q26System13MapdataGeoObjCFv);
// PAL: 0x80514208..0x80514258
UNKNOWN_FUNCTION(findSection__Q26System19MapdataFileAccessorCFUl);
// PAL: 0x80514258..0x80514368
UNKNOWN_FUNCTION(__ct__Q26System25MapdataStartPointAccessorFPCQ26System16KmpSectionHeader);
// PAL: 0x80514368..0x80514794
UNKNOWN_FUNCTION(unk_80514368);
// PAL: 0x80514794..0x805147d4
UNKNOWN_FUNCTION(unk_80514794);
// PAL: 0x805147d4..0x805147fc
UNKNOWN_FUNCTION(VEC3_fromNeg);
// PAL: 0x805147fc..0x80514810
UNKNOWN_FUNCTION(VEC3_fromQuaternionRotated);
// PAL: 0x80514810..0x80514838
UNKNOWN_FUNCTION(Vec3_scale);
// PAL: 0x80514838..0x8051486c
UNKNOWN_FUNCTION(Vec3_add);
// PAL: 0x8051486c..0x805148a0
UNKNOWN_FUNCTION(VEC3_sub);
// PAL: 0x805148a0..0x80514b24
UNKNOWN_FUNCTION(unk_805148a0);
// PAL: 0x80514b24..0x80514b30
UNKNOWN_FUNCTION(unk_80514b24);
// PAL: 0x80514b30..0x80514b7c
UNKNOWN_FUNCTION(getStartPoint__Q26System9CourseMapCFUs);
// PAL: 0x80514b7c..0x80514bc8
UNKNOWN_FUNCTION(getEnemyPoint__Q26System9CourseMapCFUs);
// PAL: 0x80514bc8..0x80514c30
UNKNOWN_FUNCTION(getEnemyPath__Q26System9CourseMapCFUs);
// PAL: 0x80514c30..0x80514d3c
UNKNOWN_FUNCTION(unk_80514c30);
// PAL: 0x80514d3c..0x80514d88
UNKNOWN_FUNCTION(getItemPoint__Q26System9CourseMapCFUs);
// PAL: 0x80514d88..0x80514df0
UNKNOWN_FUNCTION(getItemPath__Q26System9CourseMapCFUs);
// PAL: 0x80514df0..0x80515014
UNKNOWN_FUNCTION(unk_80514df0);
// PAL: 0x80515014..0x80515098
UNKNOWN_FUNCTION(CheckpathHolder_findCheckpathForCheckpoint);
// PAL: 0x80515098..0x805150e0
UNKNOWN_FUNCTION(unk_80515098);
// PAL: 0x805150e0..0x80515244
UNKNOWN_FUNCTION(unk_805150e0);
// PAL: 0x80515244..0x805154e4
UNKNOWN_FUNCTION(CheckpointHolder_init);
// PAL: 0x805154e4..0x805155e0
UNKNOWN_FUNCTION(Checkpoint_parse);
// PAL: 0x805155e0..0x805155e4
UNKNOWN_FUNCTION(unk_805155e0);
// PAL: 0x805155e4..0x80515624
UNKNOWN_FUNCTION(unk_805155e4);
// PAL: 0x80515624..0x80515a6c
UNKNOWN_FUNCTION(unk_80515624);
// PAL: 0x80515a6c..0x80515c24
UNKNOWN_FUNCTION(unk_80515a6c);
// PAL: 0x80515c24..0x80515c70
UNKNOWN_FUNCTION(getCheckPoint__Q26System9CourseMapCFUs);
// PAL: 0x80515c70..0x80515cbc
UNKNOWN_FUNCTION(getCheckPath__Q26System9CourseMapCFUs);
// PAL: 0x80515cbc..0x80515d3c
UNKNOWN_FUNCTION(unk_80515cbc);
// PAL: 0x80515d3c..0x80515e04
UNKNOWN_FUNCTION(unk_80515d3c);
// PAL: 0x80515e04..0x80515e50
UNKNOWN_FUNCTION(getPointInfo__Q26System9CourseMapCFUs);
// PAL: 0x80515e50..0x80515f8c
UNKNOWN_FUNCTION(
    __ct__Q26System19MapdataAreaAccessorFPCQ26System16KmpSectionHeader);
// PAL: 0x80515f8c..0x80516050
UNKNOWN_FUNCTION(unk_80515f8c);
// PAL: 0x80516050..0x805160b0
UNKNOWN_FUNCTION(__ct__Q26System15MapdataAreaBaseFPCQ36System15MapdataAreaBase5SData);
// PAL: 0x805160b0..0x80516138
UNKNOWN_FUNCTION(isInside__Q26System15MapdataAreaBaseCFRCQ23EGG8Vector3f);
// PAL: 0x80516138..0x80516168
UNKNOWN_FUNCTION(getRouteId__Q26System15MapdataAreaBaseCFv);
// PAL: 0x80516168..0x80516220
UNKNOWN_FUNCTION(unk_80516168);
// PAL: 0x80516220..0x805163b4
UNKNOWN_FUNCTION(AreaBox_construct);
// PAL: 0x805163b4..0x805163f4
UNKNOWN_FUNCTION(unk_805163b4);
// PAL: 0x805163f4..0x805164fc
UNKNOWN_FUNCTION(isInsideShape__Q26System14MapdataAreaBoxCFRCQ23EGG8Vector3f);
// PAL: 0x805164fc..0x80516688
UNKNOWN_FUNCTION(AreaCylinder_construct);
// PAL: 0x80516688..0x80516768
UNKNOWN_FUNCTION(isInsideShape__Q26System19MapdataAreaCylinderCFRCQ23EGG8Vector3f);
// PAL: 0x80516768..0x805167b4
UNKNOWN_FUNCTION(getArea__Q26System9CourseMapCFUs);
// PAL: 0x805167b4..0x80516808
UNKNOWN_FUNCTION(getAreaByPriority__Q26System9CourseMapCFUs);
// PAL: 0x80516808..0x80516a60
UNKNOWN_FUNCTION(unk_80516808);
// PAL: 0x80516a60..0x80516bb0
UNKNOWN_FUNCTION(unk_80516a60);
// PAL: 0x80516bb0..0x80516bfc
UNKNOWN_FUNCTION(getCamera__Q26System9CourseMapCFUs);
// PAL: 0x80516bfc..0x80516cd4
UNKNOWN_FUNCTION(unk_80516bfc);
// PAL: 0x80516cd4..0x80516d4c
UNKNOWN_FUNCTION(unk_80516cd4);
// PAL: 0x80516d4c..0x80516d74
UNKNOWN_FUNCTION(isNonPrivateBattle__Q26System17MapdataEnemyPointFv);
// PAL: 0x80516d74..0x80517590
UNKNOWN_FUNCTION(unk_80516d74);
// PAL: 0x80517590..0x8051760c
UNKNOWN_FUNCTION(unk_80517590);
// PAL: 0x8051760c..0x80517670
UNKNOWN_FUNCTION(unk_8051760c);
// PAL: 0x80517670..0x805176ec
UNKNOWN_FUNCTION(unk_80517670);
// PAL: 0x805176ec..0x80517750
UNKNOWN_FUNCTION(unk_805176ec);
// PAL: 0x80517750..0x80517858
UNKNOWN_FUNCTION(unk_80517750);
// PAL: 0x80517858..0x80517ce4
UNKNOWN_FUNCTION(unk_80517858);
// PAL: 0x80517ce4..0x80517d38
UNKNOWN_FUNCTION(unk_80517ce4);
// PAL: 0x80517d38..0x80517d8c
UNKNOWN_FUNCTION(unk_80517d38);
// PAL: 0x80517d8c..0x80517e88
UNKNOWN_FUNCTION(unk_80517d8c);
// PAL: 0x80517e88..0x805181f0
UNKNOWN_FUNCTION(unk_80517e88);
// PAL: 0x805181f0..0x80518268
UNKNOWN_FUNCTION(unk_805181f0);
// PAL: 0x80518268..0x805182cc
UNKNOWN_FUNCTION(unk_80518268);
// PAL: 0x805182cc..0x80518344
UNKNOWN_FUNCTION(unk_805182cc);
// PAL: 0x80518344..0x805183a8
UNKNOWN_FUNCTION(unk_80518344);
// PAL: 0x805183a8..0x805184fc
UNKNOWN_FUNCTION(
    __ct__Q26System17MapdataJugemPointFPCQ36System17MapdataJugemPoint5SData);
// PAL: 0x805184fc..0x80518920
UNKNOWN_FUNCTION(unk_805184fc);
// PAL: 0x80518920..0x8051896c
UNKNOWN_FUNCTION(getJugemPoint__Q26System9CourseMapCFUs);
// PAL: 0x8051896c..0x80518ab8
UNKNOWN_FUNCTION(unk_8051896c);
// PAL: 0x80518ab8..0x80518ae0
UNKNOWN_FUNCTION(Vec3_fromScale);
// PAL: 0x80518ae0..0x80518b2c
UNKNOWN_FUNCTION(getCannonPoint__Q26System9CourseMapCFUs);
// PAL: 0x80518b2c..0x80518b78
UNKNOWN_FUNCTION(getMissionPoint__Q26System9CourseMapCFUs);
// PAL: 0x80518b78..0x80518bb0
UNKNOWN_FUNCTION(getStage__Q26System9CourseMapCFv);
// PAL: 0x80518bb0..0x80518bdc
UNKNOWN_FUNCTION(getFlareAlpha__Q26System12MapdataStageCFv);
// PAL: 0x80518bdc..0x80518c40
UNKNOWN_FUNCTION(__dt__Q26System19MapdataAreaAccessorFv);
// PAL: 0x80518c40..0x80518cc0
UNKNOWN_FUNCTION(__dt__Q26System17MapdataEnemyPointFv);

#ifdef __cplusplus
}
#endif

#include <egg/math/eggVector.hpp>
#include <egg/math/eggQuat.hpp>

namespace System {

struct KmpSectionHeader {
  s32 sectionMagic;
  u16 entryCount;
  const s8 extraValue;
};

// TODO: Cleanup
template <typename T, typename TData> class MapdataAccessorBase {
public:
  T** entries;                           //!< [+0x00]
  u16 numEntries;                        //!< [+0x04]
  const KmpSectionHeader* sectionHeader; //!< [+0x08]

  /*const TData *cdata(size_t i) const {
      if (i < 0 || i > numEntries) {
          return nullptr;
      }
      return entryAccessors[i]->m_data;
  }*/
  MapdataAccessorBase(const KmpSectionHeader* header)
      : entries(nullptr), numEntries(0), sectionHeader(header) {}
  T* get(u16 i) const {
    return i < this->numEntries ? this->entries[i] : nullptr;
  }
  s8 getExtraValue() const;
  u16 size() const { return numEntries; }

  inline void init(const TData* start, u16 count) {
    if (count != 0) {
      numEntries = count;
      entries = new T*[count];
    }
    for (u16 i = 0; i < count; i++) {
      entries[i] = new T(&start[i]);
    }
  }
};
// The template will always be the same size
static_assert(sizeof(MapdataAccessorBase<unk, unk>) == 0xc);

// Despite the rest of the file being in alphabetical order, MapdataArea classes
// have been moved just above the accessor classes due to vtable ordering

// We also have to move MapdataPointInfo above MapdataGeoObj
class MapdataPointInfo {
public:
  struct SData {
    struct Point {
      EGG::Vector3f pos;
      u16 settings[2];
    };

    u16 pointCount;
    u8 settings[2];
    Point points[];
  };

  MapdataPointInfo(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataPointInfo) == 0x4);

class MapdataCamera {
public:
  struct SData {
    u8 cameraType;
    u8 cameraNext;
    u8 cameraShake;
    u8 pathID;
    u16 pathSpeed;
    u16 fovYSpeed;
    u16 viewSpeed;
    u8 startFlag;
    u8 movieFlag;
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    f32 fovYStart;
    f32 fovVYEnd;

    EGG::Vector3f viewStart;
    EGG::Vector3f viewEnd;

    f32 time;
  };

  MapdataCamera(const SData* data) : mpData(data) {}
  u8 getCameraType() const;

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataCamera) == 0x4);

class MapdataCannonPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
    u16 shootEffect;
  };

  MapdataCannonPoint(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataCannonPoint) == 0x4);

class MapdataCheckPath {
public:
  struct SData {
    u8 start;
    u8 size;

    u8 last[6];
    u8 next[6];
  };

  MapdataCheckPath(const SData* data);

private:
  SData* mpData;
  u8 _04[0x0c - 0x04];
};
static_assert(sizeof(MapdataCheckPath) == 0xc);

class MapdataCheckPoint {
public:
  struct SData {
    EGG::Vector2f left;
    EGG::Vector2f right;
    u8 jugemIndex;
    u8 lapCheck;
    u8 prevPt;
    u8 nextPt;
  };

  MapdataCheckPoint(const SData* data);

private:
  SData* mpData;
  u8 _04[0xc8 - 0x04];
};
static_assert(sizeof(MapdataCheckPoint) == 0xc8);

class MapdataEnemyPath {
public:
  struct SData {
    u8 start;
    u8 size;
    u8 last[6];
    u8 next[6];
    u8 battle_params[2];
  };

  MapdataEnemyPath(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
  u8 _04[0x0c - 0x04];
};
static_assert(sizeof(MapdataEnemyPath) == 0xc);

class MapdataEnemyPoint {
public:
  struct SData {
    EGG::Vector3f position;
    f32 deviation;
    u8 parameters[4];
  };

  MapdataEnemyPoint(const SData* data) : _08(nullptr), _0c(nullptr), _14(-1) {
    mpData = data;
  }
  virtual ~MapdataEnemyPoint();

private:
  static bool isNonPrivateBattle();

  const SData* mpData;
  unk* _08;
  unk* _0c;
  u8 _10[0x10 - 0x0c];
  u8 _14;
};
static_assert(sizeof(MapdataEnemyPoint) == 0x18);

class MapdataGeoObj {
public:
  struct SData {
    u16 id;
    EGG::Vector3f translation;
    EGG::Vector3f rotation;
    EGG::Vector3f scale;
    s16 pathId;
    u16 settings[8];
    u16 presenceFlag;
  };

  // NOTE: We cannot modify eggVector.hpp without the build failing
  // The dtor is causing a mismatch so this will have to do for now
  struct Vec3 {
    f32 x, y, z;

    inline Vec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}
  };

  MapdataGeoObj(const SData* data) : mpData(data) {
    // Writes to stack and does nothing
    Vec3 _(mpData->translation.x, mpData->translation.y, mpData->translation.z);
  }

  MapdataPointInfo* getPointInfo() const;

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataGeoObj) == 0x4);

class MapdataItemPath {
public:
  struct SData {
    u8 start;
    u8 size;

    u8 last[6];
    u8 next[6];

    u16 _0e; // Required padding
  };

  MapdataItemPath(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataItemPath) == 0x4);

class MapdataItemPoint {
public:
  struct SData {
    EGG::Vector3f position;
    f32 deviation;
    u16 parameters[2];
  };

  MapdataItemPoint(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
  u8 _04[0x14 - 0x04];
};
static_assert(sizeof(MapdataItemPoint) == 0x14);

class MapdataJugemPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
    s16 range;
  };

  MapdataJugemPoint(const SData* data);
  virtual ~MapdataJugemPoint();

private:
  SData* mpData;
  u8 _08[0x30 - 0x08];
};
static_assert(sizeof(MapdataJugemPoint) == 0x30);

class MapdataMissionPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
  };

  MapdataMissionPoint(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataMissionPoint) == 0x4);

class MapdataStage {
public:
  struct SData {
    u8 mLapCount;     // unused
    u8 mPolePosition; // should only be 0 and 1, but is not a bool
    u8 mStartConfig;  // start position player packing 0: normal, 1: tight
    bool mFlareToggle;
    u32 mFlareColor; // RGB format
    // Pre Revision 2321: End of structure
    u8 mFlareAlpha;
  };

  MapdataStage(const SData* data) : mpData(data) {}
  u8 getStartConfig() const;
  u8 getFlareAlpha() const;
  u32 getFlareColor() const;
  bool flareToggleEnabled() const;

private:
  const SData* mpData;
};
static_assert(sizeof(MapdataStage) == 0x4);

class MapdataStartPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    // Pre Revision 1830: End of structure
    s16 playerIndex;
  };

  MapdataStartPoint(const SData* data) : mpData(data) {}

private:
  const SData* mpData;
  s8 mEnemyPoint;
};
static_assert(sizeof(MapdataStartPoint) == 0x8);

class MapdataAreaBase {
public:
  struct SData {
    u8 shape;
    u8 type;
    s8 cameraIdx;
    u8 priority;
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    EGG::Vector3f scale;
    u16 parameters[2];
    // Pre Revision 2200: End of structure
    u8 railID;
    u8 eneLinkID;
  };

  MapdataAreaBase(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const = 0;

  s32 getRouteId() const;
  MapdataPointInfo* getPointInfo() const;
  bool isInside(const EGG::Vector3f& pos) const;
  void setIndex(u16 idx);

protected:
  const SData* mpData;
  EGG::Vector3f mXAxis;
  EGG::Vector3f mYAxis;
  EGG::Vector3f mZAxis;
  EGG::Vector3f mDims;
  // Only used in MapdataAreaCylinder
  f32 mEllipseXRadiusSq;
  f32 mEllipseAspectRatio;
  // Sphere enclosing area for more efficient check if point in area
  f32 mBoundingSphereRadiusSq;
  // Index in MapdataAreaAccessor array
  s16 mIndex;
};
static_assert(sizeof(MapdataAreaBase) == 0x48);

class MapdataAreaBox : public MapdataAreaBase {
public:
  MapdataAreaBox(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const;
};

class MapdataAreaCylinder : public MapdataAreaBase {
public:
  MapdataAreaCylinder(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const;
};

class MapdataAreaAccessor {
public:
  MapdataAreaAccessor(const KmpSectionHeader* header);
  u16 size() const { return numEntries; }

  MapdataAreaBase* get(u16 i) const;
  MapdataAreaBase* getByPriority(u16 i) const {
    if (i < numEntries && this->byPriority) {
      return this->byPriority[i];
    }
    return nullptr;
  }

  MapdataAreaBase** entries;
  u16 numEntries;
  virtual ~MapdataAreaAccessor();
  const KmpSectionHeader* sectionHeader;

private:
  MapdataAreaBase** byPriority;
};
static_assert(sizeof(MapdataAreaAccessor) == 0x14);
// Ensure the vtable does not exist at offset 0x0
// (It should exist at offset 0x8)
static_assert(offsetof(MapdataAreaAccessor, entries) == 0x0);

class MapdataCameraAccessor
    : public MapdataAccessorBase<MapdataCamera, MapdataCamera::SData> {
public:
  MapdataCameraAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataCamera, MapdataCamera::SData>(header) {
    init((const MapdataCamera::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }

  s8 getExtraValue() const;
};

class MapdataCannonPointAccessor
    : public MapdataAccessorBase<MapdataCannonPoint,
                                 MapdataCannonPoint::SData> {
public:
  MapdataCannonPointAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataCannonPoint, MapdataCannonPoint::SData>(
            header) {
    init((const MapdataCannonPoint::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataCheckPathAccessor
    : public MapdataAccessorBase<MapdataCheckPath, MapdataCheckPath::SData> {
private:
  f32 _0c;
};
static_assert(sizeof(MapdataCheckPathAccessor) == 0x10);

class MapdataCheckPointAccessor
    : public MapdataAccessorBase<MapdataCheckPoint, MapdataCheckPoint::SData> {
private:
  u8 _0c[0x14 - 0x0c];
};
static_assert(sizeof(MapdataCheckPointAccessor) == 0x14);

class MapdataEnemyPathAccessor
    : public MapdataAccessorBase<MapdataEnemyPath, MapdataEnemyPath::SData> {
public:
  MapdataEnemyPathAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataEnemyPath, MapdataEnemyPath::SData>(header) {
    init((const MapdataEnemyPath::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataEnemyPointAccessor
    : public MapdataAccessorBase<MapdataEnemyPoint, MapdataEnemyPoint::SData> {
public:
  MapdataEnemyPointAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataEnemyPoint, MapdataEnemyPoint::SData>(
            header) {
    init((const MapdataEnemyPoint::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataGeoObjAccessor
    : public MapdataAccessorBase<MapdataGeoObj, MapdataGeoObj::SData> {
public:
  MapdataGeoObjAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataGeoObj, MapdataGeoObj::SData>(header) {
    init((const MapdataGeoObj::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataItemPathAccessor
    : public MapdataAccessorBase<MapdataItemPath, MapdataItemPath::SData> {
public:
  MapdataItemPathAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataItemPath, MapdataItemPath::SData>(header) {
    init((const MapdataItemPath::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataItemPointAccessor
    : public MapdataAccessorBase<MapdataItemPoint, MapdataItemPoint::SData> {
public:
  MapdataItemPointAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataItemPoint, MapdataItemPoint::SData>(header) {
    init((const MapdataItemPoint::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataJugemPointAccessor
    : public MapdataAccessorBase<MapdataJugemPoint, MapdataJugemPoint::SData> {
public:
  MapdataJugemPointAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataJugemPoint, MapdataJugemPoint::SData>(
            header) {
    init((const MapdataJugemPoint::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }

  MapdataJugemPoint* get(u16 i) const;
};

class MapdataMissionPointAccessor
    : public MapdataAccessorBase<MapdataMissionPoint,
                                 MapdataMissionPoint::SData> {
public:
  MapdataMissionPointAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataMissionPoint, MapdataMissionPoint::SData>(
            header) {
    init((const MapdataMissionPoint::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataPointInfoAccessor
    : public MapdataAccessorBase<MapdataPointInfo, MapdataPointInfo::SData> {
public:
  // We need the init function defined before the constructor
  void init(u16 entryCount) {
    if (entryCount != 0) {
      numEntries = entryCount;
      entries = new MapdataPointInfo*[entryCount];
    }
    if (numEntries != 0) {
      u16 i = 0;
      const MapdataPointInfo::SData* route =
          (const MapdataPointInfo::SData*)sectionHeader + 2;
      for (; i < numEntries; i++) {
        entries[i] = new MapdataPointInfo(route);
        route = route + route->pointCount * 4 + 1;
      }
    }
  }

  // TODO: scheduling conflicts in source
  MapdataPointInfoAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataPointInfo, MapdataPointInfo::SData>(header) {
    init(sectionHeader->entryCount);
  }
};

class MapdataStageAccessor
    : public MapdataAccessorBase<MapdataStage, MapdataStage::SData> {
public:
  MapdataStageAccessor(const KmpSectionHeader* header)
      : MapdataAccessorBase<MapdataStage, MapdataStage::SData>(header) {
    init((const MapdataStage::SData*)(sectionHeader + 1),
         sectionHeader->entryCount);
  }
};

class MapdataStartPointAccessor
    : public MapdataAccessorBase<MapdataStartPoint, MapdataStartPoint::SData> {
public:
  MapdataStartPointAccessor(const KmpSectionHeader* header);

  MapdataStartPoint* get(u16 i) const;
};

class MapdataFileAccessor {
public:
  struct SData {
    u32 magic;
    u32 fileSize;
    u16 numSections;
    u16 headerSize;
    u32 revision;
    s32 offsets[];
  };

  MapdataFileAccessor(const SData* data);
  u32 getVersion() const;
  const KmpSectionHeader* findSection(u32 sectionName) const;

private:
  const SData* mpData;
  u32* mpSectionDef;
  u32 mVersion;
  u32 mSectionDefOffset;
};
static_assert(sizeof(MapdataFileAccessor) == 0x10);

class CourseMap {
public:
  static CourseMap* createInstance();
  static void destroyInstance();
  static inline CourseMap* instance() { return spInstance; }
  static void* loadFile(s32 archiveIdx, const char* filename);

  inline u32 getVersion() const { return mpCourse->getVersion(); }

  MapdataAreaBase* getArea(u16 i) const;
  MapdataAreaBase* getAreaByPriority(u16 i) const;
  MapdataCannonPoint* getCannonPoint(u16 i) const;
  MapdataCamera* getCamera(u16 i) const;
  MapdataCheckPoint* getCheckPoint(u16 i) const;
  MapdataCheckPath* getCheckPath(u16 i) const;
  MapdataEnemyPath* getEnemyPath(u16 i) const;
  MapdataEnemyPoint* getEnemyPoint(u16 i) const;
  MapdataGeoObj* getGeoObj(u16 i) const;
  MapdataItemPoint* getItemPoint(u16 i) const;
  MapdataItemPath* getItemPath(u16 i) const;
  MapdataJugemPoint* getJugemPoint(u16 i) const;
  MapdataMissionPoint* getMissionPoint(u16 i) const;
  MapdataPointInfo* getPointInfo(u16 i) const;
  MapdataStage* getStage() const;
  MapdataStartPoint* getStartPoint(u16 i) const;

  u16 getAreaCount() const;
  u16 getCameraCount() const;
  u16 getEnemyPointCount() const;
  u16 getItemPointCount() const;
  u16 getJugemPointCount() const;
  u16 getStartPointCount() const;

  /*template <typename T, typename TAccessor>
  TAccessor* parse(u32 sectionName);*/
  MapdataAreaAccessor* parseAreas(u32 sectionName);
  MapdataCameraAccessor* parseCameras(u32 sectionName);
  MapdataCannonPointAccessor* parseCannonPoints(u32 sectionName);
  MapdataEnemyPathAccessor* parseEnemyPaths(u32 sectionName);
  MapdataEnemyPointAccessor* parseEnemyPoints(u32 sectionName);
  MapdataGeoObjAccessor* parseGeoObjs(u32 sectionName);
  MapdataItemPathAccessor* parseItemPaths(u32 sectionName);
  MapdataItemPointAccessor* parseItemPoints(u32 sectionName);
  MapdataJugemPointAccessor* parseJugemPoints(u32 sectionName);
  MapdataStartPointAccessor* parseKartpoints(u32 sectionName);
  MapdataMissionPointAccessor* parseMissionPoints(u32 sectionName);
  MapdataPointInfoAccessor* parsePointInfo(u32 sectionName);
  MapdataStageAccessor* parseStage(u32 sectionName);

private:
  CourseMap();
  virtual ~CourseMap();

  static CourseMap* spInstance;

  MapdataFileAccessor* mpCourse;

  MapdataStartPointAccessor* mpStartPoint;
  MapdataEnemyPathAccessor* mpEnemyPath;
  MapdataEnemyPointAccessor* mpEnemyPoint;
  MapdataItemPathAccessor* mpItemPath;
  MapdataItemPointAccessor* mpItemPoint;
  MapdataCheckPathAccessor* mpCheckPath;
  MapdataCheckPointAccessor* mpCheckPoint;
  MapdataPointInfoAccessor* mpPointInfo;
  MapdataGeoObjAccessor* mpGeoObj;
  MapdataAreaAccessor* mpArea;
  MapdataCameraAccessor* mpCamera;
  MapdataJugemPointAccessor* mpJugemPoint;
  MapdataCannonPointAccessor* mpCannonPoint;
  MapdataStageAccessor* mpStageInfo;
  MapdataMissionPointAccessor* mpMissionPoint;

  void* mpGoalCamera;
  void* mpType9Camera;
  void* mpOpeningPanCamera;
  unk _50;
};

} // namespace System
