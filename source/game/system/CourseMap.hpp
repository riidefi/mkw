#pragma once

#include <rk_types.h>

#include <decomp.h>

#ifdef __cplusplus
extern "C" {
#endif

// PAL: 0x80512694..0x8051271c
UNKNOWN_FUNCTION(createInstance__Q26System9CourseMapFv);
// PAL: 0x8051271c..0x8051276c
UNKNOWN_FUNCTION(destroyInstance__Q26System9CourseMapFv);
// PAL: 0x8051276c..0x805127ac
UNKNOWN_FUNCTION(__ct__Q25Field9CourseMapFv);
// PAL: 0x805127ac..0x805127ec
UNKNOWN_FUNCTION(__dt__Q25Field9CourseMapFv);
// PAL: 0x805127ec..0x80512c10
UNKNOWN_FUNCTION(CourseMap_init);
// PAL: 0x80512c10..0x80512c2c
UNKNOWN_FUNCTION(loadFile__Q26System9CourseMapFlPCc);
// PAL: 0x80512c2c..0x80512c6c
UNKNOWN_FUNCTION(CourseMapHeader_ct);
// PAL: 0x80512c6c..0x80512c78
UNKNOWN_FUNCTION(unk_80512c6c);
// PAL: 0x80512c78..0x80512c94
UNKNOWN_FUNCTION(unk_80512c78);
// PAL: 0x80512c94..0x80512c9c
UNKNOWN_FUNCTION(unk_80512c94);
// PAL: 0x80512c9c..0x80512cac
UNKNOWN_FUNCTION(unk_80512c9c);
// PAL: 0x80512cac..0x80512cb4
UNKNOWN_FUNCTION(unk_80512cac);
// PAL: 0x80512cb4..0x80512cd0
UNKNOWN_FUNCTION(unk_80512cb4);
// PAL: 0x80512cd0..0x80512cec
UNKNOWN_FUNCTION(unk_80512cd0);
// PAL: 0x80512cec..0x80512d08
UNKNOWN_FUNCTION(unk_80512cec);
// PAL: 0x80512d08..0x80512d24
UNKNOWN_FUNCTION(unk_80512d08);
// PAL: 0x80512d24..0x80512d40
UNKNOWN_FUNCTION(unk_80512d24);
// PAL: 0x80512d40..0x80512d4c
UNKNOWN_FUNCTION(Stageinfo_isNarrowMode);
// PAL: 0x80512d4c..0x80512d58
UNKNOWN_FUNCTION(unk_80512d4c);
// PAL: 0x80512d58..0x80512d64
UNKNOWN_FUNCTION(unk_80512d58);
// PAL: 0x80512d64..0x80512e84
UNKNOWN_FUNCTION(KmpHolder_parseStageinfo);
// PAL: 0x80512e84..0x80512fa4
UNKNOWN_FUNCTION(unk_80512e84);
// PAL: 0x80512fa4..0x805130c4
UNKNOWN_FUNCTION(KmpHolder_parseCannonpoints);
// PAL: 0x805130c4..0x805131e4
UNKNOWN_FUNCTION(unk_805130c4);
// PAL: 0x805131e4..0x80513304
UNKNOWN_FUNCTION(unk_805131e4);
// PAL: 0x80513304..0x80513398
UNKNOWN_FUNCTION(KmpHolder_parseAreas);
// PAL: 0x80513398..0x805134c8
UNKNOWN_FUNCTION(unk_80513398);
// PAL: 0x805134c8..0x80513600
UNKNOWN_FUNCTION(KmpHolder_parseGlobalobjs);
// PAL: 0x80513600..0x80513640
UNKNOWN_FUNCTION(unk_80513600);
// PAL: 0x80513640..0x8051377c
UNKNOWN_FUNCTION(KmpHolder_parseCheckpoints);
// PAL: 0x8051377c..0x80513adc
UNKNOWN_FUNCTION(KmpHolder_parseCheckpaths);
// PAL: 0x80513adc..0x80513bfc
UNKNOWN_FUNCTION(unk_80513adc);
// PAL: 0x80513bfc..0x80513d18
UNKNOWN_FUNCTION(unk_80513bfc);
// PAL: 0x80513d18..0x80513e40
UNKNOWN_FUNCTION(KmpHolder_parseEnemyPoint);
// PAL: 0x80513e40..0x80513f5c
UNKNOWN_FUNCTION(KmpHolder_parseEnemyPath);
// PAL: 0x80513f5c..0x805140dc
UNKNOWN_FUNCTION(KmpHolder_parseKartpoints);
// PAL: 0x805140dc..0x80514100
UNKNOWN_FUNCTION(AreaHolder_get);
// PAL: 0x80514100..0x80514124
UNKNOWN_FUNCTION(unk_80514100);
// PAL: 0x80514124..0x80514148
UNKNOWN_FUNCTION(KartpointHolder_getKartpoint);
// PAL: 0x80514148..0x80514194
UNKNOWN_FUNCTION(KmpHolder_getGlobalObj);
// PAL: 0x80514194..0x80514208
UNKNOWN_FUNCTION(unk_80514194);
// PAL: 0x80514208..0x80514258
UNKNOWN_FUNCTION(unk_80514208);
// PAL: 0x80514258..0x80514368
UNKNOWN_FUNCTION(unk_80514258);
// PAL: 0x80514368..0x80514794
UNKNOWN_FUNCTION(unk_80514368);
// PAL: 0x80514794..0x805147d4
UNKNOWN_FUNCTION(unk_80514794);
// PAL: 0x805147d4..0x805147fc
UNKNOWN_FUNCTION(VEC3_fromNeg);
// PAL: 0x805147fc..0x80514810
UNKNOWN_FUNCTION(VEC3_fromQuaternionRotated);
// PAL: 0x80514810..0x80514838
UNKNOWN_FUNCTION(Vec3_scale);
// PAL: 0x80514838..0x8051486c
UNKNOWN_FUNCTION(Vec3_add);
// PAL: 0x8051486c..0x805148a0
UNKNOWN_FUNCTION(VEC3_sub);
// PAL: 0x805148a0..0x80514b24
UNKNOWN_FUNCTION(unk_805148a0);
// PAL: 0x80514b24..0x80514b30
UNKNOWN_FUNCTION(unk_80514b24);
// PAL: 0x80514b30..0x80514b7c
UNKNOWN_FUNCTION(KmpHolder_getKartpoint);
// PAL: 0x80514b7c..0x80514bc8
UNKNOWN_FUNCTION(KmpHolder_getEnemypoint);
// PAL: 0x80514bc8..0x80514c30
UNKNOWN_FUNCTION(unk_80514bc8);
// PAL: 0x80514c30..0x80514d3c
UNKNOWN_FUNCTION(unk_80514c30);
// PAL: 0x80514d3c..0x80514d88
UNKNOWN_FUNCTION(KmpHolder_getItempath);
// PAL: 0x80514d88..0x80514df0
UNKNOWN_FUNCTION(unk_80514d88);
// PAL: 0x80514df0..0x80515014
UNKNOWN_FUNCTION(unk_80514df0);
// PAL: 0x80515014..0x80515098
UNKNOWN_FUNCTION(CheckpathHolder_findCheckpathForCheckpoint);
// PAL: 0x80515098..0x805150e0
UNKNOWN_FUNCTION(unk_80515098);
// PAL: 0x805150e0..0x80515244
UNKNOWN_FUNCTION(unk_805150e0);
// PAL: 0x80515244..0x805154e4
UNKNOWN_FUNCTION(CheckpointHolder_init);
// PAL: 0x805154e4..0x805155e0
UNKNOWN_FUNCTION(Checkpoint_parse);
// PAL: 0x805155e0..0x805155e4
UNKNOWN_FUNCTION(unk_805155e0);
// PAL: 0x805155e4..0x80515624
UNKNOWN_FUNCTION(unk_805155e4);
// PAL: 0x80515624..0x80515a6c
UNKNOWN_FUNCTION(unk_80515624);
// PAL: 0x80515a6c..0x80515c24
UNKNOWN_FUNCTION(unk_80515a6c);
// PAL: 0x80515c24..0x80515c70
UNKNOWN_FUNCTION(KmpHolder_getCheckpoint);
// PAL: 0x80515c70..0x80515cbc
UNKNOWN_FUNCTION(unk_80515c70);
// PAL: 0x80515cbc..0x80515d3c
UNKNOWN_FUNCTION(unk_80515cbc);
// PAL: 0x80515d3c..0x80515e04
UNKNOWN_FUNCTION(unk_80515d3c);
// PAL: 0x80515e04..0x80515e50
UNKNOWN_FUNCTION(unk_80515e04);
// PAL: 0x80515e50..0x80515f8c
UNKNOWN_FUNCTION(AreaHolder_construct);
// PAL: 0x80515f8c..0x80516050
UNKNOWN_FUNCTION(unk_80515f8c);
// PAL: 0x80516050..0x805160b0
UNKNOWN_FUNCTION(unk_80516050);
// PAL: 0x805160b0..0x80516138
UNKNOWN_FUNCTION(unk_805160b0);
// PAL: 0x80516138..0x80516168
UNKNOWN_FUNCTION(unk_80516138);
// PAL: 0x80516168..0x80516220
UNKNOWN_FUNCTION(unk_80516168);
// PAL: 0x80516220..0x805163b4
UNKNOWN_FUNCTION(AreaBox_construct);
// PAL: 0x805163b4..0x805163f4
UNKNOWN_FUNCTION(unk_805163b4);
// PAL: 0x805163f4..0x805164fc
UNKNOWN_FUNCTION(unk_805163f4);
// PAL: 0x805164fc..0x80516688
UNKNOWN_FUNCTION(AreaCylinder_construct);
// PAL: 0x80516688..0x80516768
UNKNOWN_FUNCTION(unk_80516688);
// PAL: 0x80516768..0x805167b4
UNKNOWN_FUNCTION(KmpHolder_getArea);
// PAL: 0x805167b4..0x80516808
UNKNOWN_FUNCTION(unk_805167b4);
// PAL: 0x80516808..0x80516a60
UNKNOWN_FUNCTION(unk_80516808);
// PAL: 0x80516a60..0x80516bb0
UNKNOWN_FUNCTION(unk_80516a60);
// PAL: 0x80516bb0..0x80516bfc
UNKNOWN_FUNCTION(unk_80516bb0);
// PAL: 0x80516bfc..0x80516cd4
UNKNOWN_FUNCTION(unk_80516bfc);
// PAL: 0x80516cd4..0x80516d4c
UNKNOWN_FUNCTION(unk_80516cd4);
// PAL: 0x80516d4c..0x80516d74
UNKNOWN_FUNCTION(unk_80516d4c);
// PAL: 0x80516d74..0x80517590
UNKNOWN_FUNCTION(unk_80516d74);
// PAL: 0x80517590..0x8051760c
UNKNOWN_FUNCTION(unk_80517590);
// PAL: 0x8051760c..0x80517670
UNKNOWN_FUNCTION(unk_8051760c);
// PAL: 0x80517670..0x805176ec
UNKNOWN_FUNCTION(unk_80517670);
// PAL: 0x805176ec..0x80517750
UNKNOWN_FUNCTION(unk_805176ec);
// PAL: 0x80517750..0x80517858
UNKNOWN_FUNCTION(unk_80517750);
// PAL: 0x80517858..0x80517ce4
UNKNOWN_FUNCTION(unk_80517858);
// PAL: 0x80517ce4..0x80517d38
UNKNOWN_FUNCTION(unk_80517ce4);
// PAL: 0x80517d38..0x80517d8c
UNKNOWN_FUNCTION(unk_80517d38);
// PAL: 0x80517d8c..0x80517e88
UNKNOWN_FUNCTION(unk_80517d8c);
// PAL: 0x80517e88..0x805181f0
UNKNOWN_FUNCTION(unk_80517e88);
// PAL: 0x805181f0..0x80518268
UNKNOWN_FUNCTION(unk_805181f0);
// PAL: 0x80518268..0x805182cc
UNKNOWN_FUNCTION(unk_80518268);
// PAL: 0x805182cc..0x80518344
UNKNOWN_FUNCTION(unk_805182cc);
// PAL: 0x80518344..0x805183a8
UNKNOWN_FUNCTION(unk_80518344);
// PAL: 0x805183a8..0x805184fc
UNKNOWN_FUNCTION(unk_805183a8);
// PAL: 0x805184fc..0x80518920
UNKNOWN_FUNCTION(unk_805184fc);
// PAL: 0x80518920..0x8051896c
UNKNOWN_FUNCTION(unk_80518920);
// PAL: 0x8051896c..0x80518ab8
UNKNOWN_FUNCTION(unk_8051896c);
// PAL: 0x80518ab8..0x80518ae0
UNKNOWN_FUNCTION(Vec3_fromScale);
// PAL: 0x80518ae0..0x80518b2c
UNKNOWN_FUNCTION(KmpHolder_getCannonpoint);
// PAL: 0x80518b2c..0x80518b78
UNKNOWN_FUNCTION(unk_80518b2c);
// PAL: 0x80518b78..0x80518bb0
UNKNOWN_FUNCTION(KmpHolder_getStageinfo);
// PAL: 0x80518bb0..0x80518bdc
UNKNOWN_FUNCTION(unk_80518bb0);
// PAL: 0x80518bdc..0x80518c40
UNKNOWN_FUNCTION(unk_80518bdc);
// PAL: 0x80518c40..0x80518cc0
UNKNOWN_FUNCTION(Enemypoint_destroy);

#ifdef __cplusplus
}
#endif

#include <egg/math/eggVector.hpp>

namespace System {

struct KmpSectionHeader {
  s32 sectionMagic;
  u16 entryCount;
  s16 extraValue;
};

template <typename T, typename TData> struct MapdataAccessorBase {
  T** entries;                     //!< [+0x00]
  u16 numEntries;                  //!< [+0x04]
  KmpSectionHeader* sectionHeader; //!< [+0x08]

  /*const TData *cdata(size_t i) const {
      if (i < 0 || i > numEntries) {
          return nullptr;
      }
      return entryAccessors[i]->m_data;
  }*/
  T* get(u16 i);
};
// The template will always be the same size
static_assert(sizeof(MapdataAccessorBase<unk, unk>) == 0xc);

class MapdataAreaBase {
public:
  struct SData {
    u8 shape;
    u8 type;
    s8 cameraIdx;
    u8 priority;
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    EGG::Vector3f scale;
    u16 parameters[2];
    // Pre Revision 2200: End of structure
    u8 railID;
    u8 eneLinkID;
  };

  MapdataAreaBase(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const = 0;

private:
  SData* mpData;
  u8 _08[0x48 - 0x08];
};
static_assert(sizeof(MapdataAreaBase) == 0x48);

class MapdataAreaBox : public MapdataAreaBase {
public:
  MapdataAreaBox(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const;
};

class MapdataAreaCylinder : public MapdataAreaBase {
public:
  MapdataAreaCylinder(const SData* data);
  virtual bool isInsideShape(const EGG::Vector3f& pos) const;
};

class MapdataCamera {
public:
  struct SData {
    u8 cameraType;
    u8 cameraNext;
    u8 cameraShake;
    u8 pathID;
    u16 pathSpeed;
    u16 fovYSpeed;
    u16 viewSpeed;
    u8 startFlag;
    u8 movieFlag;
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    f32 fovYStart;
    f32 fovVYEnd;

    EGG::Vector3f viewStart;
    EGG::Vector3f viewEnd;

    float time;
  };

  MapdataCamera(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataCamera) == 0x4);

class MapdataCannonPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
    u16 shootEffect;
  };

  MapdataCannonPoint(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataCannonPoint) == 0x4);

class MapdataCheckPath {
public:
  struct SData {
    u8 start;
    u8 size;

    u8 last[6];
    u8 next[6];
  };

  MapdataCheckPath(const SData* data);

private:
  SData* mpData;
  u8 _04[0x0c - 0x04];
};
static_assert(sizeof(MapdataCheckPath) == 0xc);

class MapdataCheckPoint {
public:
  struct SData {
    EGG::Vector2f left;
    EGG::Vector2f right;
    u8 jugemIndex;
    u8 lapCheck;
    u8 prevPt;
    u8 nextPt;
  };

  MapdataCheckPoint(const SData* data);

private:
  SData* mpData;
  u8 _04[0xc8 - 0x04];
};
static_assert(sizeof(MapdataCheckPoint) == 0xc8);

class MapdataEnemyPath {
public:
  struct SData {
    u8 start;
    u8 size;
    u8 last[6];
    u8 next[6];
    u8 battle_params[2];
  };

  MapdataEnemyPath(const SData* data);

private:
  SData* mpData;
  u8 _04[0x08 - 0x04];
};
static_assert(sizeof(MapdataEnemyPath) == 0x8);

class MapdataEnemyPoint {
public:
  struct SData {
    EGG::Vector3f position;
    f32 deviation;
    u8 parameters[4];
  };

  MapdataEnemyPoint(const SData* data);

private:
  SData* mpData;
  u8 _04[0x18 - 0x04];
};
static_assert(sizeof(MapdataEnemyPoint) == 0x18);

class MapdataFileAccessor {
public:
  struct SData {
    u32 magic;
    u32 fileSize;
    u16 numSections;
    u16 headerSize;
    u32 revision;
    s32 offsets[];
  };

  MapdataFileAccessor(const SData* data);

private:
  SData* mpData;
  void* mpSectionDef;
  u32 mVersion;
  u32 mSectionDefOffset;
};
static_assert(sizeof(MapdataFileAccessor) == 0x10);

class MapdataGeoObj {
public:
  struct SData {
    u16 id;
    EGG::Vector3f translation;
    EGG::Vector3f rotation;
    EGG::Vector3f scale;
    s16 pathId;
    u16 settings[8];
    u16 presenceFlag;
  };

  MapdataGeoObj(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataGeoObj) == 0x4);

class MapdataItemPath {
public:
  struct SData {
    u8 start;
    u8 size;

    u8 last[6];
    u8 next[6];
  };

  MapdataItemPath(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataItemPath) == 0x4);

class MapdataItemPoint {
public:
  struct SData {
    EGG::Vector3f position;
    f32 deviation;
    u16 parameters[2];
  };

  MapdataItemPoint(const SData* data);

private:
  SData* mpData;
  u8 _04[0x10 - 0x04];
};
static_assert(sizeof(MapdataItemPoint) == 0x10);

class MapdataJugemPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
    s16 range;
  };

  MapdataJugemPoint(const SData* data);
  virtual ~MapdataJugemPoint();

private:
  SData* mpData;
  u8 _08[0x30 - 0x08];
};
static_assert(sizeof(MapdataJugemPoint) == 0x30);

class MapdataMissionPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    u16 id;
  };

  MapdataMissionPoint(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataMissionPoint) == 0x4);

class MapdataPointInfo {
public:
  struct SData {
    // TODO: decomp
  };

  MapdataPointInfo(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataPointInfo) == 0x4);

class MapdataStage {
public:
  struct SData {
    u8 mLapCount;      // unused
    u8 mPolePosition;  // should only be 0 and 1, but is not a bool
    u8 mStartPosition; // should only be 0 and 1, but is not a bool
    bool mFlareToggle;
    u32 mFlareColor; // RGB format
    // Pre Revision 2321: End of structure
    u8 mFlareAlpha;
  };

  MapdataStage(const SData* data);

private:
  SData* mpData;
};
static_assert(sizeof(MapdataStage) == 0x4);

class MapdataStartPoint {
public:
  struct SData {
    EGG::Vector3f position;
    EGG::Vector3f rotation;
    // Pre Revision 1830: End of structure
    s16 playerIndex;
  };

  MapdataStartPoint(const SData* data);

private:
  SData* mpData;
  s8 mEnemyPoint;
};
static_assert(sizeof(MapdataStartPoint) == 0x8);

// TODO: MapdataAreaAccessor

typedef MapdataAccessorBase<MapdataCamera, MapdataCamera::SData>
    MapdataCameraAccessor;

typedef MapdataAccessorBase<MapdataCannonPoint, MapdataCannonPoint::SData>
    MapdataCannonPointAccessor;

class MapdataCheckPathAccessor
    : public MapdataAccessorBase<MapdataCheckPath, MapdataCheckPath::SData> {
private:
  f32 _0c;
};
static_assert(sizeof(MapdataCheckPathAccessor) == 0x10);

class MapdataCheckPointAccessor
    : public MapdataAccessorBase<MapdataCheckPoint, MapdataCheckPoint::SData> {
private:
  u8 _0c[0x14 - 0x0c];
};
static_assert(sizeof(MapdataCheckPointAccessor) == 0x14);

typedef MapdataAccessorBase<MapdataEnemyPath, MapdataEnemyPath::SData>
    MapdataEnemyPathAccessor;

typedef MapdataAccessorBase<MapdataEnemyPoint, MapdataEnemyPoint::SData>
    MapdataEnemyPointAccessor;

typedef MapdataAccessorBase<MapdataGeoObj, MapdataGeoObj::SData>
    MapdataGeoObjAccessor;

typedef MapdataAccessorBase<MapdataItemPoint, MapdataItemPoint::SData>
    MapdataItemPointAccessor;

typedef MapdataAccessorBase<MapdataItemPath, MapdataItemPath::SData>
    MapdataItemPathAccessor;

typedef MapdataAccessorBase<MapdataJugemPoint, MapdataJugemPoint::SData>
    MapdataJugemPointAccessor;

typedef MapdataAccessorBase<MapdataMissionPoint, MapdataMissionPoint::SData>
    MapdataMissionPointAccessor;

typedef MapdataAccessorBase<MapdataPointInfo, MapdataPointInfo::SData>
    MapdataPointInfoAccessor;

typedef MapdataAccessorBase<MapdataStage, MapdataStage::SData>
    MapdataStageAccessor;

typedef MapdataAccessorBase<MapdataStartPoint, MapdataStartPoint::SData>
    MapdataStartPointAccessor;

class CourseMap {
public:
  static CourseMap* createInstance();
  static void destroyInstance();

  static void* loadFile(s32 archiveIdx, const char* filename);

  static inline CourseMap* instance() { return spInstance; }

private:
  CourseMap();
  virtual ~CourseMap();

  static CourseMap* spInstance;

  MapdataFileAccessor* mpCourse;

  MapdataStartPointAccessor* mpKartPoint;
  MapdataEnemyPathAccessor* mpEnemyPath;
  MapdataEnemyPointAccessor* mpEnemyPoint;
  MapdataItemPathAccessor* mpItemPath;
  MapdataItemPointAccessor* mpItemPoint;
  MapdataCheckPathAccessor* mpCheckPath;
  MapdataCheckPointAccessor* mpCheckPoint;
  MapdataPointInfoAccessor* mpPointInfo;
  MapdataGeoObjAccessor* mpGeoObj;
  void* mpArea;
  MapdataCameraAccessor* mpCamera;
  MapdataJugemPointAccessor* mpJugemPoint;
  MapdataCannonPointAccessor* mpCannonPoint;
  MapdataStageAccessor* mpStageInfo;
  MapdataMissionPointAccessor* mpMissionPoint;

  void* mpGoalCamera;
  void* mpType9Camera;
  void* mpOpeningPanCamera;
  unk _50;
};

} // namespace System
